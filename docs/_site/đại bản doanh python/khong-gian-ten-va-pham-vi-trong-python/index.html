<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.26.2 by Michael Rose
  Copyright 2013-2024 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en-US" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Không gian tên(namespace) và phạm vi(scope) trong Python - BeautyOnCode</title>
<meta name="description" content="Khi mình ngồi học và dịch bài “Class trong Python” cho sê-ri “Khám Phá Đại Bản Doanh Python”, mình đã đụng hai bạn này, và các bạn thật là trừu tượng và khó gặm. Thế là mình tìm kiếm và viết bài này để hiểu rõ hơn về hai bạn ấy, hi vọng bạn đọc thêm để hiểu về Python nhé.  Không gian tên là gì?  Không gian tên(namespace) là một không gian chứa các tên =))  Thật đó, tên là các định danh, và không gian là các cấu trúc hay các tổ chức, hoặc hiểu đơn giản nó là một vùng nào đó.  Không gian tên trong Python giống như là bảng phân công theo dõi công việc của một nhóm người vậy đó. Bảng phân công thì theo dõi tên người, còn không gian tên trong Python thì theo dõi tên các đối tượng.  Thế đối tượng trong Python là gì nhỉ?  Có thể bạn đã biết, mọi thứ trong Python đều là đối tượng. Khi mình viết chương trình Python, chúng ta định nghĩa các lớp và mô-đun; sử dụng các cấu trúc list, dict; các thực thể và các hàm.  Tất cả bọn chúng đều là đối tượng cả đó.  Không gian tên trong Python thì theo dõi tên các đối tượng, chẳng hạn như các như các thực thể của đối tượng và các hàm chức năng. Dưới đây là vài đặc điểm quan trọng của khái niệm này:  Không gian tên thể hiện ở dạng từ điển  Vì không gian tên thể hiện ánh xạ giữa tên và đối tượng, do đó kiểu dữ liệu có thể thể hiện tham chiếu này chính là từ điển(dict), vì bạn ấy cũng có dạng tham chiếu key-value.  Ví dụ về không gian tên bằng gọi hàm globals(), locals():  &gt;&gt;&gt; a = [1, 2, 3, 4, 5] &gt;&gt;&gt; &gt;&gt;&gt; def foo(): ...     b = 11 ...     print(locals()) ... &gt;&gt;&gt; class Student: ...     pass ... &gt;&gt;&gt; student = Student() &gt;&gt;&gt; print(globals()) {&#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None, &#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &#39;__spec__&#39;: None, &#39;__annotations__&#39;: {}, &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;, &#39;a&#39;: [1, 2, 3, 4, 5], &#39;b&#39;: &#39;Hello World!&#39;, &#39;foo&#39;: &lt;function foo at 0x101fd93b0&gt;, &#39;foo0&#39;: &lt;function foo at 0x10200c7a0&gt;, &#39;foo1&#39;: &lt;function foo at 0x10200c7a0&gt;, &#39;tracked_namespaces&#39;: {&#39;local&#39;: {}}, &#39;tracked_keys&#39;: dict_keys([&#39;local&#39;]), &#39;ns&#39;: &lt;module &#39;namespaces_student&#39; from &#39;/Users/ycui/PythonProjects/namespaces_student.py&#39;&gt;, &#39;working_hard&#39;: True, &#39;Student&#39;: &lt;class &#39;__main__.Student&#39;&gt;, &#39;Teacher&#39;: &lt;class &#39;namespaces_teacher.Teacher&#39;&gt;, &#39;student&#39;: &lt;__main__.Student object at 0x102027490&gt;} &gt;&gt;&gt; foo() {&#39;b&#39;: 11}   Hàm dựng sẵn globals() dùng để xem các định danh đi kèm với các đối tượng tương ứng của chính trong không gian tên hiện tại. Kết quả là danh sách các đối tượng được định nghĩa như list, function, class hay thực thể và các hàm dựng sẵn.  Bên cạnh globals() được sử dụng để theo dõi các đối tượng trong mô-đun như ở không gian tên toàn cục như trên, chúng ta còn có thể dùng locals() là hàm theo dõi các đối tượng trong một hàm nào đó như là không gian tên địa phương của hàm đó. Trong ví dụ, biến địa phương b được theo dõi trong không gian tên địa phương của hàm foo.  Không gian tên có tính linh hoạt  Không gian tên được dùng để theo dõi các đối tượng.  Trong Python code, chúng ta tạo ra các đối tượng cố định và xoá các đối tượng không còn được dùng nữa, do đó không gian tên cũng sẽ thay đổi theo dựa trên các thao tác này.  Cùng xem ví dụ khi thực hiện thao tác thêm và xoá các thuộc tính sẽ làm thay đổi không gian tên:  &gt;&gt;&gt; a = [1, 2, 3, 4, 5] &gt;&gt;&gt; print(globals().keys()) dict_keys([&#39;__name__&#39;, &#39;__doc__&#39;, &#39;__package__&#39;, &#39;__loader__&#39;, &#39;__spec__&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;a&#39;]) &gt;&gt;&gt; b, c = &#39;Hi&#39;, (1, 2) &gt;&gt;&gt; print(globals().keys()) dict_keys([&#39;__name__&#39;, &#39;__doc__&#39;, &#39;__package__&#39;, &#39;__loader__&#39;, &#39;__spec__&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) &gt;&gt;&gt; del c &gt;&gt;&gt; print(globals().keys()) dict_keys([&#39;__name__&#39;, &#39;__doc__&#39;, &#39;__package__&#39;, &#39;__loader__&#39;, &#39;__spec__&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;a&#39;, &#39;b&#39;])   Khi một hàm được gọi, nó tạo ra một không gian tên cục bộ, và không gian tên này sẽ mất đi khi hàm hoàn thành nhiệm vụ của mình(trả về giá trị hoặc raise lỗi). Khi đó, không gian tên cũng sẽ bị thay đối.  Phạm vi là hàng rào của không gian tên  Để cho dễ hình dung, bạn có thể nghĩ đến scope như là hàng rào quanh nhà bạn, còn namespace là toàn bộ đất trong đó, và trên đất có thể bao gồm cây cối, nhà cửa, …. là các đối tượng.    Bạn thấy không, không gian tên theo dõi các đối tượng trong mô-đun này, vì tụi này nằm trong không gian của nó, còn phạm vi chính là đường màu cam thể hiện hàng rào bọc ngoài không gian tên này.  Nói cách khác, nếu mình muốn sử dụng attr0 nằm trong mô-đun ở trên ở một hàm “bo” chẳng hạn, nếu hàm này không thể truy cập vào phạm vi này thì không thể dùng biến đó được.  Cùng xem một ví dụ nhé:  Đây là code trong file namespace_student.py  working_hard = True  class Student:    def study(self):       print(&quot;I&#39;m studing.&quot;)   Truy cập vào trình biên dịch PI:  &gt;&gt;&gt; print(f&#39;working_hard: {working_hard}&#39;) Traceback (most recent call last):   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; NameError: name &#39;working_hard&#39; is not defined &gt;&gt;&gt; import namespace_student as ns &gt;&gt;&gt; print(f&#39;working_hard: {ns.working_hard}&#39;) working_hard: True &gt;&gt;&gt; print(globals()) {&#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None, &#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &#39;__spec__&#39;: None, &#39;__annotations__&#39;: {}, &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;, &#39;ns&#39;: &lt;module &#39;namespace_student&#39; from &#39;/Users/thanhnguyen/Desktop/namespace/namespace_student.py&#39;&gt;}   Khi mình làm việc trong PI, mô-đun mặc định ở đây là main, nơi không gian tên có __main__ là giá trị của __name__.  Dòng đầu tiên print, mình không thể truy cập vào biến working_hard vì tụi mình đang không đứng trong mô-đun namespace_student. Tuy nhiên, sau khi mình nạp mô-đun này vào, thì mình có thể truy cập tên này không qua tên mô-đun của nó vì ns đã thuộc không gian tên nơi mình đang đứng(main). Mình có thể kiểm tra điều đó bằng hàm in ra không gian tên globals như ở trên.  Vì mình có thể dùng tên của mô-đun để truy cập vào các thuộc tính trong đó, cho nên ở các mô-đun khác nhau hoàn toàn có thể chứa các tên giống nhau.  Bạn có thể hình dung nó kiểu như là nhà mình có một cái macbook, nhà hàng xóm cũng có một cái macbook y như vậy, thì hai cái macbook này mình có thể hoàn toàn phân biệt được đúng không nào 😀    Không gian tên và phạm vi đều phân cấp  Bạn có để ý thấy chỉ cần truy cập vào trình biên dịch là mình có thể sử dụng các hàm dựng sẵn của Python như print() hay các kiểu dữ liệu như dict(), list().  Vậy các bạn này từ đâu ra thế nhỉ ? Vâng, các bạn này thuộc không gian tên dựng sẵn(built-in) đó ạ.  Còn khi tạo một mô-đun, ta sẽ có không gian tên toàn cục(global) của mô-đun đó, khi tạo một hàm mình có không gian tên cục bộ(local) của hàm đó. Khi các không gian tên được tạo thì các phạm vi tương ứng của chúng cũng được tạo.     Đặc điểm quan trọng của không gian tên là chúng có mối quan hệ phân cấp như vậy.   Biểu đồ dưới thể hiện sự phân cấp này: không gian tên và phạm vi dựng sẵn bao trùm không gian tên và phạm vi toàn cục, và lớp này bao trùm không gian tên và phạm vi cục bộ.    Hiểu luật LEGB  Vì phạm vi xác định việc có thể truy cập đối tượng trong một ranh giới nhất định và chúng có tính phân cấp như trên, những điều này dẫn đến việc chúng cần hiểu và nắm quy luật LEGB – một nguyên tắc giúp xác định thứ tự các phạm vi.  LEGB là viết tắc của các phạm vi local, enclosing, global và built-in.  Ở trên, mình có đề cập đến các loại phạm vi: local, global, built-in rồi. Thế còn phạm vi bao quanh(enclosing) nghĩa là gì nhỉ?  Cùng nhìn ví dụ sau về phạm vi bao quanh nha:    Ở ví dụ trên, mình có hàm outer_function có hàm bên trong là inner_function, hàm này có phạm vi cục bộ của riêng nó. Với hàm inner_function, phạm vi của hàm outer_function gọi là phạm vi bao quanh(enclosing scope), tức nó bọc luôn hàm bên trong.  Do đó khi hàm inner_function được goi, dù local scope của nó không có hai biến a, b, nhưng trình thông dịch tiếp tục tìm kiếm ở enclosing scope và tìm được hai biến này, do đó kết quả trên được hiển thị ba biến a, b, c.  Nếu không thể tìm thấy biến cần tìm không enclosing scope, chương trình sẽ tiếp tục tìm kiếm ở global scope của mô-đun và nếu không có nữa sẽ tìm kiếm tới built-in scope.  Nếu tìm hết bốn scope mà vẫn không tìm ra thì chương trình sẽ báo lỗi NameError để chỉ cho mình biết giá trị này chưa được định nghĩa.  Do đó, nguyên tắc LEGB định nghĩa thứ tự tìm kiếm của tên theo thứ tự như sau:    Và thêm nữa, nếu tên đã được tìm kiếm ở cấp nào rồi, thì chương trình sẽ dừng việc tìm kiếm lại và sử dụng tên đó chứ không đi tìm ở những lớp trên nữa nha, vì tìm ra rồi thì dùng liền chớ hỉ.  Ví dụ như ở trên biến a gọi trong hàm inner_function sẽ có giá trị là 11, chứ chương trình không tìm tiếp cấp ở ngoài, nơi a có giá trị là 1 đó.  Kết  Nội dung bài không gian tên và phạm vi đến đây tạm hết rồi, cùng ôn lại hôm ni mình học được gì:          Không gian tên sử dụng dict để theo dõi các đối tượng cùng định danh của chúng           Không gian tên có thể tạo thêm hay xoá bớt một cách linh hoạt           Không gian tên có ranh giới chính là scope, định nghĩa phạm vi tên có thể tìm thấy           Thứ tự tìm tên tuân theo luật LEGB(local, enclosing, global, built-in)">


  <meta name="author" content="Thanh Nguyen">
  
  <meta property="article:author" content="Thanh Nguyen">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="BeautyOnCode">
<meta property="og:title" content="Không gian tên(namespace) và phạm vi(scope) trong Python">
<meta property="og:url" content="http://localhost:4000/%C4%91%E1%BA%A1i%20b%E1%BA%A3n%20doanh%20python/khong-gian-ten-va-pham-vi-trong-python/">


  <meta property="og:description" content="Khi mình ngồi học và dịch bài “Class trong Python” cho sê-ri “Khám Phá Đại Bản Doanh Python”, mình đã đụng hai bạn này, và các bạn thật là trừu tượng và khó gặm. Thế là mình tìm kiếm và viết bài này để hiểu rõ hơn về hai bạn ấy, hi vọng bạn đọc thêm để hiểu về Python nhé.  Không gian tên là gì?  Không gian tên(namespace) là một không gian chứa các tên =))  Thật đó, tên là các định danh, và không gian là các cấu trúc hay các tổ chức, hoặc hiểu đơn giản nó là một vùng nào đó.  Không gian tên trong Python giống như là bảng phân công theo dõi công việc của một nhóm người vậy đó. Bảng phân công thì theo dõi tên người, còn không gian tên trong Python thì theo dõi tên các đối tượng.  Thế đối tượng trong Python là gì nhỉ?  Có thể bạn đã biết, mọi thứ trong Python đều là đối tượng. Khi mình viết chương trình Python, chúng ta định nghĩa các lớp và mô-đun; sử dụng các cấu trúc list, dict; các thực thể và các hàm.  Tất cả bọn chúng đều là đối tượng cả đó.  Không gian tên trong Python thì theo dõi tên các đối tượng, chẳng hạn như các như các thực thể của đối tượng và các hàm chức năng. Dưới đây là vài đặc điểm quan trọng của khái niệm này:  Không gian tên thể hiện ở dạng từ điển  Vì không gian tên thể hiện ánh xạ giữa tên và đối tượng, do đó kiểu dữ liệu có thể thể hiện tham chiếu này chính là từ điển(dict), vì bạn ấy cũng có dạng tham chiếu key-value.  Ví dụ về không gian tên bằng gọi hàm globals(), locals():  &gt;&gt;&gt; a = [1, 2, 3, 4, 5] &gt;&gt;&gt; &gt;&gt;&gt; def foo(): ...     b = 11 ...     print(locals()) ... &gt;&gt;&gt; class Student: ...     pass ... &gt;&gt;&gt; student = Student() &gt;&gt;&gt; print(globals()) {&#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None, &#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &#39;__spec__&#39;: None, &#39;__annotations__&#39;: {}, &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;, &#39;a&#39;: [1, 2, 3, 4, 5], &#39;b&#39;: &#39;Hello World!&#39;, &#39;foo&#39;: &lt;function foo at 0x101fd93b0&gt;, &#39;foo0&#39;: &lt;function foo at 0x10200c7a0&gt;, &#39;foo1&#39;: &lt;function foo at 0x10200c7a0&gt;, &#39;tracked_namespaces&#39;: {&#39;local&#39;: {}}, &#39;tracked_keys&#39;: dict_keys([&#39;local&#39;]), &#39;ns&#39;: &lt;module &#39;namespaces_student&#39; from &#39;/Users/ycui/PythonProjects/namespaces_student.py&#39;&gt;, &#39;working_hard&#39;: True, &#39;Student&#39;: &lt;class &#39;__main__.Student&#39;&gt;, &#39;Teacher&#39;: &lt;class &#39;namespaces_teacher.Teacher&#39;&gt;, &#39;student&#39;: &lt;__main__.Student object at 0x102027490&gt;} &gt;&gt;&gt; foo() {&#39;b&#39;: 11}   Hàm dựng sẵn globals() dùng để xem các định danh đi kèm với các đối tượng tương ứng của chính trong không gian tên hiện tại. Kết quả là danh sách các đối tượng được định nghĩa như list, function, class hay thực thể và các hàm dựng sẵn.  Bên cạnh globals() được sử dụng để theo dõi các đối tượng trong mô-đun như ở không gian tên toàn cục như trên, chúng ta còn có thể dùng locals() là hàm theo dõi các đối tượng trong một hàm nào đó như là không gian tên địa phương của hàm đó. Trong ví dụ, biến địa phương b được theo dõi trong không gian tên địa phương của hàm foo.  Không gian tên có tính linh hoạt  Không gian tên được dùng để theo dõi các đối tượng.  Trong Python code, chúng ta tạo ra các đối tượng cố định và xoá các đối tượng không còn được dùng nữa, do đó không gian tên cũng sẽ thay đổi theo dựa trên các thao tác này.  Cùng xem ví dụ khi thực hiện thao tác thêm và xoá các thuộc tính sẽ làm thay đổi không gian tên:  &gt;&gt;&gt; a = [1, 2, 3, 4, 5] &gt;&gt;&gt; print(globals().keys()) dict_keys([&#39;__name__&#39;, &#39;__doc__&#39;, &#39;__package__&#39;, &#39;__loader__&#39;, &#39;__spec__&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;a&#39;]) &gt;&gt;&gt; b, c = &#39;Hi&#39;, (1, 2) &gt;&gt;&gt; print(globals().keys()) dict_keys([&#39;__name__&#39;, &#39;__doc__&#39;, &#39;__package__&#39;, &#39;__loader__&#39;, &#39;__spec__&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) &gt;&gt;&gt; del c &gt;&gt;&gt; print(globals().keys()) dict_keys([&#39;__name__&#39;, &#39;__doc__&#39;, &#39;__package__&#39;, &#39;__loader__&#39;, &#39;__spec__&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;a&#39;, &#39;b&#39;])   Khi một hàm được gọi, nó tạo ra một không gian tên cục bộ, và không gian tên này sẽ mất đi khi hàm hoàn thành nhiệm vụ của mình(trả về giá trị hoặc raise lỗi). Khi đó, không gian tên cũng sẽ bị thay đối.  Phạm vi là hàng rào của không gian tên  Để cho dễ hình dung, bạn có thể nghĩ đến scope như là hàng rào quanh nhà bạn, còn namespace là toàn bộ đất trong đó, và trên đất có thể bao gồm cây cối, nhà cửa, …. là các đối tượng.    Bạn thấy không, không gian tên theo dõi các đối tượng trong mô-đun này, vì tụi này nằm trong không gian của nó, còn phạm vi chính là đường màu cam thể hiện hàng rào bọc ngoài không gian tên này.  Nói cách khác, nếu mình muốn sử dụng attr0 nằm trong mô-đun ở trên ở một hàm “bo” chẳng hạn, nếu hàm này không thể truy cập vào phạm vi này thì không thể dùng biến đó được.  Cùng xem một ví dụ nhé:  Đây là code trong file namespace_student.py  working_hard = True  class Student:    def study(self):       print(&quot;I&#39;m studing.&quot;)   Truy cập vào trình biên dịch PI:  &gt;&gt;&gt; print(f&#39;working_hard: {working_hard}&#39;) Traceback (most recent call last):   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; NameError: name &#39;working_hard&#39; is not defined &gt;&gt;&gt; import namespace_student as ns &gt;&gt;&gt; print(f&#39;working_hard: {ns.working_hard}&#39;) working_hard: True &gt;&gt;&gt; print(globals()) {&#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None, &#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &#39;__spec__&#39;: None, &#39;__annotations__&#39;: {}, &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;, &#39;ns&#39;: &lt;module &#39;namespace_student&#39; from &#39;/Users/thanhnguyen/Desktop/namespace/namespace_student.py&#39;&gt;}   Khi mình làm việc trong PI, mô-đun mặc định ở đây là main, nơi không gian tên có __main__ là giá trị của __name__.  Dòng đầu tiên print, mình không thể truy cập vào biến working_hard vì tụi mình đang không đứng trong mô-đun namespace_student. Tuy nhiên, sau khi mình nạp mô-đun này vào, thì mình có thể truy cập tên này không qua tên mô-đun của nó vì ns đã thuộc không gian tên nơi mình đang đứng(main). Mình có thể kiểm tra điều đó bằng hàm in ra không gian tên globals như ở trên.  Vì mình có thể dùng tên của mô-đun để truy cập vào các thuộc tính trong đó, cho nên ở các mô-đun khác nhau hoàn toàn có thể chứa các tên giống nhau.  Bạn có thể hình dung nó kiểu như là nhà mình có một cái macbook, nhà hàng xóm cũng có một cái macbook y như vậy, thì hai cái macbook này mình có thể hoàn toàn phân biệt được đúng không nào 😀    Không gian tên và phạm vi đều phân cấp  Bạn có để ý thấy chỉ cần truy cập vào trình biên dịch là mình có thể sử dụng các hàm dựng sẵn của Python như print() hay các kiểu dữ liệu như dict(), list().  Vậy các bạn này từ đâu ra thế nhỉ ? Vâng, các bạn này thuộc không gian tên dựng sẵn(built-in) đó ạ.  Còn khi tạo một mô-đun, ta sẽ có không gian tên toàn cục(global) của mô-đun đó, khi tạo một hàm mình có không gian tên cục bộ(local) của hàm đó. Khi các không gian tên được tạo thì các phạm vi tương ứng của chúng cũng được tạo.     Đặc điểm quan trọng của không gian tên là chúng có mối quan hệ phân cấp như vậy.   Biểu đồ dưới thể hiện sự phân cấp này: không gian tên và phạm vi dựng sẵn bao trùm không gian tên và phạm vi toàn cục, và lớp này bao trùm không gian tên và phạm vi cục bộ.    Hiểu luật LEGB  Vì phạm vi xác định việc có thể truy cập đối tượng trong một ranh giới nhất định và chúng có tính phân cấp như trên, những điều này dẫn đến việc chúng cần hiểu và nắm quy luật LEGB – một nguyên tắc giúp xác định thứ tự các phạm vi.  LEGB là viết tắc của các phạm vi local, enclosing, global và built-in.  Ở trên, mình có đề cập đến các loại phạm vi: local, global, built-in rồi. Thế còn phạm vi bao quanh(enclosing) nghĩa là gì nhỉ?  Cùng nhìn ví dụ sau về phạm vi bao quanh nha:    Ở ví dụ trên, mình có hàm outer_function có hàm bên trong là inner_function, hàm này có phạm vi cục bộ của riêng nó. Với hàm inner_function, phạm vi của hàm outer_function gọi là phạm vi bao quanh(enclosing scope), tức nó bọc luôn hàm bên trong.  Do đó khi hàm inner_function được goi, dù local scope của nó không có hai biến a, b, nhưng trình thông dịch tiếp tục tìm kiếm ở enclosing scope và tìm được hai biến này, do đó kết quả trên được hiển thị ba biến a, b, c.  Nếu không thể tìm thấy biến cần tìm không enclosing scope, chương trình sẽ tiếp tục tìm kiếm ở global scope của mô-đun và nếu không có nữa sẽ tìm kiếm tới built-in scope.  Nếu tìm hết bốn scope mà vẫn không tìm ra thì chương trình sẽ báo lỗi NameError để chỉ cho mình biết giá trị này chưa được định nghĩa.  Do đó, nguyên tắc LEGB định nghĩa thứ tự tìm kiếm của tên theo thứ tự như sau:    Và thêm nữa, nếu tên đã được tìm kiếm ở cấp nào rồi, thì chương trình sẽ dừng việc tìm kiếm lại và sử dụng tên đó chứ không đi tìm ở những lớp trên nữa nha, vì tìm ra rồi thì dùng liền chớ hỉ.  Ví dụ như ở trên biến a gọi trong hàm inner_function sẽ có giá trị là 11, chứ chương trình không tìm tiếp cấp ở ngoài, nơi a có giá trị là 1 đó.  Kết  Nội dung bài không gian tên và phạm vi đến đây tạm hết rồi, cùng ôn lại hôm ni mình học được gì:          Không gian tên sử dụng dict để theo dõi các đối tượng cùng định danh của chúng           Không gian tên có thể tạo thêm hay xoá bớt một cách linh hoạt           Không gian tên có ranh giới chính là scope, định nghĩa phạm vi tên có thể tìm thấy           Thứ tự tìm tên tuân theo luật LEGB(local, enclosing, global, built-in)">



  <meta property="og:image" content="http://localhost:4000/assets/images/site-logo.png">



  <meta name="twitter:site" content="@mmistakes">
  <meta name="twitter:title" content="Không gian tên(namespace) và phạm vi(scope) trong Python">
  <meta name="twitter:description" content="Khi mình ngồi học và dịch bài “Class trong Python” cho sê-ri “Khám Phá Đại Bản Doanh Python”, mình đã đụng hai bạn này, và các bạn thật là trừu tượng và khó gặm. Thế là mình tìm kiếm và viết bài này để hiểu rõ hơn về hai bạn ấy, hi vọng bạn đọc thêm để hiểu về Python nhé.  Không gian tên là gì?  Không gian tên(namespace) là một không gian chứa các tên =))  Thật đó, tên là các định danh, và không gian là các cấu trúc hay các tổ chức, hoặc hiểu đơn giản nó là một vùng nào đó.  Không gian tên trong Python giống như là bảng phân công theo dõi công việc của một nhóm người vậy đó. Bảng phân công thì theo dõi tên người, còn không gian tên trong Python thì theo dõi tên các đối tượng.  Thế đối tượng trong Python là gì nhỉ?  Có thể bạn đã biết, mọi thứ trong Python đều là đối tượng. Khi mình viết chương trình Python, chúng ta định nghĩa các lớp và mô-đun; sử dụng các cấu trúc list, dict; các thực thể và các hàm.  Tất cả bọn chúng đều là đối tượng cả đó.  Không gian tên trong Python thì theo dõi tên các đối tượng, chẳng hạn như các như các thực thể của đối tượng và các hàm chức năng. Dưới đây là vài đặc điểm quan trọng của khái niệm này:  Không gian tên thể hiện ở dạng từ điển  Vì không gian tên thể hiện ánh xạ giữa tên và đối tượng, do đó kiểu dữ liệu có thể thể hiện tham chiếu này chính là từ điển(dict), vì bạn ấy cũng có dạng tham chiếu key-value.  Ví dụ về không gian tên bằng gọi hàm globals(), locals():  &gt;&gt;&gt; a = [1, 2, 3, 4, 5] &gt;&gt;&gt; &gt;&gt;&gt; def foo(): ...     b = 11 ...     print(locals()) ... &gt;&gt;&gt; class Student: ...     pass ... &gt;&gt;&gt; student = Student() &gt;&gt;&gt; print(globals()) {&#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None, &#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &#39;__spec__&#39;: None, &#39;__annotations__&#39;: {}, &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;, &#39;a&#39;: [1, 2, 3, 4, 5], &#39;b&#39;: &#39;Hello World!&#39;, &#39;foo&#39;: &lt;function foo at 0x101fd93b0&gt;, &#39;foo0&#39;: &lt;function foo at 0x10200c7a0&gt;, &#39;foo1&#39;: &lt;function foo at 0x10200c7a0&gt;, &#39;tracked_namespaces&#39;: {&#39;local&#39;: {}}, &#39;tracked_keys&#39;: dict_keys([&#39;local&#39;]), &#39;ns&#39;: &lt;module &#39;namespaces_student&#39; from &#39;/Users/ycui/PythonProjects/namespaces_student.py&#39;&gt;, &#39;working_hard&#39;: True, &#39;Student&#39;: &lt;class &#39;__main__.Student&#39;&gt;, &#39;Teacher&#39;: &lt;class &#39;namespaces_teacher.Teacher&#39;&gt;, &#39;student&#39;: &lt;__main__.Student object at 0x102027490&gt;} &gt;&gt;&gt; foo() {&#39;b&#39;: 11}   Hàm dựng sẵn globals() dùng để xem các định danh đi kèm với các đối tượng tương ứng của chính trong không gian tên hiện tại. Kết quả là danh sách các đối tượng được định nghĩa như list, function, class hay thực thể và các hàm dựng sẵn.  Bên cạnh globals() được sử dụng để theo dõi các đối tượng trong mô-đun như ở không gian tên toàn cục như trên, chúng ta còn có thể dùng locals() là hàm theo dõi các đối tượng trong một hàm nào đó như là không gian tên địa phương của hàm đó. Trong ví dụ, biến địa phương b được theo dõi trong không gian tên địa phương của hàm foo.  Không gian tên có tính linh hoạt  Không gian tên được dùng để theo dõi các đối tượng.  Trong Python code, chúng ta tạo ra các đối tượng cố định và xoá các đối tượng không còn được dùng nữa, do đó không gian tên cũng sẽ thay đổi theo dựa trên các thao tác này.  Cùng xem ví dụ khi thực hiện thao tác thêm và xoá các thuộc tính sẽ làm thay đổi không gian tên:  &gt;&gt;&gt; a = [1, 2, 3, 4, 5] &gt;&gt;&gt; print(globals().keys()) dict_keys([&#39;__name__&#39;, &#39;__doc__&#39;, &#39;__package__&#39;, &#39;__loader__&#39;, &#39;__spec__&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;a&#39;]) &gt;&gt;&gt; b, c = &#39;Hi&#39;, (1, 2) &gt;&gt;&gt; print(globals().keys()) dict_keys([&#39;__name__&#39;, &#39;__doc__&#39;, &#39;__package__&#39;, &#39;__loader__&#39;, &#39;__spec__&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) &gt;&gt;&gt; del c &gt;&gt;&gt; print(globals().keys()) dict_keys([&#39;__name__&#39;, &#39;__doc__&#39;, &#39;__package__&#39;, &#39;__loader__&#39;, &#39;__spec__&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;a&#39;, &#39;b&#39;])   Khi một hàm được gọi, nó tạo ra một không gian tên cục bộ, và không gian tên này sẽ mất đi khi hàm hoàn thành nhiệm vụ của mình(trả về giá trị hoặc raise lỗi). Khi đó, không gian tên cũng sẽ bị thay đối.  Phạm vi là hàng rào của không gian tên  Để cho dễ hình dung, bạn có thể nghĩ đến scope như là hàng rào quanh nhà bạn, còn namespace là toàn bộ đất trong đó, và trên đất có thể bao gồm cây cối, nhà cửa, …. là các đối tượng.    Bạn thấy không, không gian tên theo dõi các đối tượng trong mô-đun này, vì tụi này nằm trong không gian của nó, còn phạm vi chính là đường màu cam thể hiện hàng rào bọc ngoài không gian tên này.  Nói cách khác, nếu mình muốn sử dụng attr0 nằm trong mô-đun ở trên ở một hàm “bo” chẳng hạn, nếu hàm này không thể truy cập vào phạm vi này thì không thể dùng biến đó được.  Cùng xem một ví dụ nhé:  Đây là code trong file namespace_student.py  working_hard = True  class Student:    def study(self):       print(&quot;I&#39;m studing.&quot;)   Truy cập vào trình biên dịch PI:  &gt;&gt;&gt; print(f&#39;working_hard: {working_hard}&#39;) Traceback (most recent call last):   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; NameError: name &#39;working_hard&#39; is not defined &gt;&gt;&gt; import namespace_student as ns &gt;&gt;&gt; print(f&#39;working_hard: {ns.working_hard}&#39;) working_hard: True &gt;&gt;&gt; print(globals()) {&#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None, &#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &#39;__spec__&#39;: None, &#39;__annotations__&#39;: {}, &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;, &#39;ns&#39;: &lt;module &#39;namespace_student&#39; from &#39;/Users/thanhnguyen/Desktop/namespace/namespace_student.py&#39;&gt;}   Khi mình làm việc trong PI, mô-đun mặc định ở đây là main, nơi không gian tên có __main__ là giá trị của __name__.  Dòng đầu tiên print, mình không thể truy cập vào biến working_hard vì tụi mình đang không đứng trong mô-đun namespace_student. Tuy nhiên, sau khi mình nạp mô-đun này vào, thì mình có thể truy cập tên này không qua tên mô-đun của nó vì ns đã thuộc không gian tên nơi mình đang đứng(main). Mình có thể kiểm tra điều đó bằng hàm in ra không gian tên globals như ở trên.  Vì mình có thể dùng tên của mô-đun để truy cập vào các thuộc tính trong đó, cho nên ở các mô-đun khác nhau hoàn toàn có thể chứa các tên giống nhau.  Bạn có thể hình dung nó kiểu như là nhà mình có một cái macbook, nhà hàng xóm cũng có một cái macbook y như vậy, thì hai cái macbook này mình có thể hoàn toàn phân biệt được đúng không nào 😀    Không gian tên và phạm vi đều phân cấp  Bạn có để ý thấy chỉ cần truy cập vào trình biên dịch là mình có thể sử dụng các hàm dựng sẵn của Python như print() hay các kiểu dữ liệu như dict(), list().  Vậy các bạn này từ đâu ra thế nhỉ ? Vâng, các bạn này thuộc không gian tên dựng sẵn(built-in) đó ạ.  Còn khi tạo một mô-đun, ta sẽ có không gian tên toàn cục(global) của mô-đun đó, khi tạo một hàm mình có không gian tên cục bộ(local) của hàm đó. Khi các không gian tên được tạo thì các phạm vi tương ứng của chúng cũng được tạo.     Đặc điểm quan trọng của không gian tên là chúng có mối quan hệ phân cấp như vậy.   Biểu đồ dưới thể hiện sự phân cấp này: không gian tên và phạm vi dựng sẵn bao trùm không gian tên và phạm vi toàn cục, và lớp này bao trùm không gian tên và phạm vi cục bộ.    Hiểu luật LEGB  Vì phạm vi xác định việc có thể truy cập đối tượng trong một ranh giới nhất định và chúng có tính phân cấp như trên, những điều này dẫn đến việc chúng cần hiểu và nắm quy luật LEGB – một nguyên tắc giúp xác định thứ tự các phạm vi.  LEGB là viết tắc của các phạm vi local, enclosing, global và built-in.  Ở trên, mình có đề cập đến các loại phạm vi: local, global, built-in rồi. Thế còn phạm vi bao quanh(enclosing) nghĩa là gì nhỉ?  Cùng nhìn ví dụ sau về phạm vi bao quanh nha:    Ở ví dụ trên, mình có hàm outer_function có hàm bên trong là inner_function, hàm này có phạm vi cục bộ của riêng nó. Với hàm inner_function, phạm vi của hàm outer_function gọi là phạm vi bao quanh(enclosing scope), tức nó bọc luôn hàm bên trong.  Do đó khi hàm inner_function được goi, dù local scope của nó không có hai biến a, b, nhưng trình thông dịch tiếp tục tìm kiếm ở enclosing scope và tìm được hai biến này, do đó kết quả trên được hiển thị ba biến a, b, c.  Nếu không thể tìm thấy biến cần tìm không enclosing scope, chương trình sẽ tiếp tục tìm kiếm ở global scope của mô-đun và nếu không có nữa sẽ tìm kiếm tới built-in scope.  Nếu tìm hết bốn scope mà vẫn không tìm ra thì chương trình sẽ báo lỗi NameError để chỉ cho mình biết giá trị này chưa được định nghĩa.  Do đó, nguyên tắc LEGB định nghĩa thứ tự tìm kiếm của tên theo thứ tự như sau:    Và thêm nữa, nếu tên đã được tìm kiếm ở cấp nào rồi, thì chương trình sẽ dừng việc tìm kiếm lại và sử dụng tên đó chứ không đi tìm ở những lớp trên nữa nha, vì tìm ra rồi thì dùng liền chớ hỉ.  Ví dụ như ở trên biến a gọi trong hàm inner_function sẽ có giá trị là 11, chứ chương trình không tìm tiếp cấp ở ngoài, nơi a có giá trị là 1 đó.  Kết  Nội dung bài không gian tên và phạm vi đến đây tạm hết rồi, cùng ôn lại hôm ni mình học được gì:          Không gian tên sử dụng dict để theo dõi các đối tượng cùng định danh của chúng           Không gian tên có thể tạo thêm hay xoá bớt một cách linh hoạt           Không gian tên có ranh giới chính là scope, định nghĩa phạm vi tên có thể tìm thấy           Thứ tự tìm tên tuân theo luật LEGB(local, enclosing, global, built-in)">
  <meta name="twitter:url" content="http://localhost:4000/%C4%91%E1%BA%A1i%20b%E1%BA%A3n%20doanh%20python/khong-gian-ten-va-pham-vi-trong-python/">

  
    <meta name="twitter:card" content="summary">
    
      <meta name="twitter:image" content="http://localhost:4000/assets/images/site-logo.png">
    
  

  



  <meta property="article:published_time" content="2021-06-16T00:00:00-04:00">



  <meta property="article:modified_time" content="2020-06-16T15:12:19-04:00">



  

  


<link rel="canonical" href="http://localhost:4000/%C4%91%E1%BA%A1i%20b%E1%BA%A3n%20doanh%20python/khong-gian-ten-va-pham-vi-trong-python/">







  <meta name="google-site-verification" content="UQj93ERU9zgECodaaXgVpkjrFn9UrDMEzVamacSoQ8Y" />






<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="BeautyOnCode Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  window.enable_copy_code_button = true;
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->
<link rel="icon" type="image/png" href="assets/images/favicon/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="assets/images/favicon/favicon.svg" />
<link rel="shortcut icon" href="assets/images/favicon/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="assets/images/favicon/apple-touch-icon.png" />
<link rel="manifest" href="assets/images/favicon/site.webmanifest" />
<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/logo/logo-circle.webp" alt="BeautyOnCode"></a>
        
        <a class="site-title" href="/">
          BeautyOnCode
          <span class="site-subtitle">Code Your Life In An Elegant Way</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/docs/getting-started/"
                
                
              >Getting Started</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li><li class="masthead__menu-item">
              <a
                href="/year-archive/"
                
                
              >Posts</a>
            </li><li class="masthead__menu-item">
              <a
                href="/collection-archive/"
                
                
              >Collections</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person" class="h-card">

  
    <div class="author__avatar">
      <a href="http://localhost:4000/">
        <img src="/assets/images/logo/thanh-nguyen.jpg" alt="Thanh Nguyen" itemprop="image" class="u-photo">
      </a>
    </div>
  

  <div class="author__content">
    <h3 class="author__name p-name" itemprop="name">
      <a class="u-url" rel="me" href="http://localhost:4000/" itemprop="url">Thanh Nguyen</a>
    </h3>
    
      <div class="author__bio p-note" itemprop="description">
        <p>Web developer, nature lover, curious soul, and laid-back mom balancing code with life’s simple joys.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name" class="p-locality">Da Nang, VN</span>
        </li>
      

      
        
          
            <li><a href="https://beautyoncode.com" rel="nofollow noopener noreferrer me" itemprop="sameAs"><i class="fas fa-fw fa-link" aria-hidden="true"></i><span class="label">BeautyOnCode</span></a></li>
          
        
          
            <li><a href="https://www.linkedin.com/in/graphicdthanh/" rel="nofollow noopener noreferrer me" itemprop="sameAs"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span class="label">Linkedin</span></a></li>
          
        
          
            <li><a href="https://github.com/GraphicDThanh" rel="nofollow noopener noreferrer me" itemprop="sameAs"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
            <li><a href="https://www.facebook.com/beautyoncode" rel="nofollow noopener noreferrer me" itemprop="sameAs"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span class="label">Facebook</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer me">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Không gian tên(namespace) và phạm vi(scope) trong Python">
    <meta itemprop="description" content="Khi mình ngồi học và dịch bài “Class trong Python” cho sê-ri “Khám Phá Đại Bản Doanh Python”, mình đã đụng hai bạn này, và các bạn thật là trừu tượng và khó gặm. Thế là mình tìm kiếm và viết bài này để hiểu rõ hơn về hai bạn ấy, hi vọng bạn đọc thêm để hiểu về Python nhé.Không gian tên là gì?Không gian tên(namespace) là một không gian chứa các tên =))Thật đó, tên là các định danh, và không gian là các cấu trúc hay các tổ chức, hoặc hiểu đơn giản nó là một vùng nào đó.Không gian tên trong Python giống như là bảng phân công theo dõi công việc của một nhóm người vậy đó. Bảng phân công thì theo dõi tên người, còn không gian tên trong Python thì theo dõi tên các đối tượng.Thế đối tượng trong Python là gì nhỉ?Có thể bạn đã biết, mọi thứ trong Python đều là đối tượng. Khi mình viết chương trình Python, chúng ta định nghĩa các lớp và mô-đun; sử dụng các cấu trúc list, dict; các thực thể và các hàm.  Tất cả bọn chúng đều là đối tượng cả đó.Không gian tên trong Python thì theo dõi tên các đối tượng, chẳng hạn như các như các thực thể của đối tượng và các hàm chức năng. Dưới đây là vài đặc điểm quan trọng của khái niệm này:Không gian tên thể hiện ở dạng từ điểnVì không gian tên thể hiện ánh xạ giữa tên và đối tượng, do đó kiểu dữ liệu có thể thể hiện tham chiếu này chính là từ điển(dict), vì bạn ấy cũng có dạng tham chiếu key-value.Ví dụ về không gian tên bằng gọi hàm globals(), locals():&gt;&gt;&gt; a = [1, 2, 3, 4, 5]&gt;&gt;&gt;&gt;&gt;&gt; def foo():...     b = 11...     print(locals())...&gt;&gt;&gt; class Student:...     pass...&gt;&gt;&gt; student = Student()&gt;&gt;&gt; print(globals()){&#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None, &#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &#39;__spec__&#39;: None, &#39;__annotations__&#39;: {}, &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;, &#39;a&#39;: [1, 2, 3, 4, 5], &#39;b&#39;: &#39;Hello World!&#39;, &#39;foo&#39;: &lt;function foo at 0x101fd93b0&gt;, &#39;foo0&#39;: &lt;function foo at 0x10200c7a0&gt;, &#39;foo1&#39;: &lt;function foo at 0x10200c7a0&gt;, &#39;tracked_namespaces&#39;: {&#39;local&#39;: {}}, &#39;tracked_keys&#39;: dict_keys([&#39;local&#39;]), &#39;ns&#39;: &lt;module &#39;namespaces_student&#39; from &#39;/Users/ycui/PythonProjects/namespaces_student.py&#39;&gt;, &#39;working_hard&#39;: True, &#39;Student&#39;: &lt;class &#39;__main__.Student&#39;&gt;, &#39;Teacher&#39;: &lt;class &#39;namespaces_teacher.Teacher&#39;&gt;, &#39;student&#39;: &lt;__main__.Student object at 0x102027490&gt;}&gt;&gt;&gt; foo(){&#39;b&#39;: 11}Hàm dựng sẵn globals() dùng để xem các định danh đi kèm với các đối tượng tương ứng của chính trong không gian tên hiện tại. Kết quả là danh sách các đối tượng được định nghĩa như list, function, class hay thực thể và các hàm dựng sẵn.Bên cạnh globals() được sử dụng để theo dõi các đối tượng trong mô-đun như ở không gian tên toàn cục như trên, chúng ta còn có thể dùng locals() là hàm theo dõi các đối tượng trong một hàm nào đó như là không gian tên địa phương của hàm đó. Trong ví dụ, biến địa phương b được theo dõi trong không gian tên địa phương của hàm foo.Không gian tên có tính linh hoạtKhông gian tên được dùng để theo dõi các đối tượng.Trong Python code, chúng ta tạo ra các đối tượng cố định và xoá các đối tượng không còn được dùng nữa, do đó không gian tên cũng sẽ thay đổi theo dựa trên các thao tác này.Cùng xem ví dụ khi thực hiện thao tác thêm và xoá các thuộc tính sẽ làm thay đổi không gian tên:&gt;&gt;&gt; a = [1, 2, 3, 4, 5]&gt;&gt;&gt; print(globals().keys())dict_keys([&#39;__name__&#39;, &#39;__doc__&#39;, &#39;__package__&#39;, &#39;__loader__&#39;, &#39;__spec__&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;a&#39;])&gt;&gt;&gt; b, c = &#39;Hi&#39;, (1, 2)&gt;&gt;&gt; print(globals().keys())dict_keys([&#39;__name__&#39;, &#39;__doc__&#39;, &#39;__package__&#39;, &#39;__loader__&#39;, &#39;__spec__&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;])&gt;&gt;&gt; del c&gt;&gt;&gt; print(globals().keys())dict_keys([&#39;__name__&#39;, &#39;__doc__&#39;, &#39;__package__&#39;, &#39;__loader__&#39;, &#39;__spec__&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;a&#39;, &#39;b&#39;])Khi một hàm được gọi, nó tạo ra một không gian tên cục bộ, và không gian tên này sẽ mất đi khi hàm hoàn thành nhiệm vụ của mình(trả về giá trị hoặc raise lỗi). Khi đó, không gian tên cũng sẽ bị thay đối.Phạm vi là hàng rào của không gian tênĐể cho dễ hình dung, bạn có thể nghĩ đến scope như là hàng rào quanh nhà bạn, còn namespace là toàn bộ đất trong đó, và trên đất có thể bao gồm cây cối, nhà cửa, …. là các đối tượng.Bạn thấy không, không gian tên theo dõi các đối tượng trong mô-đun này, vì tụi này nằm trong không gian của nó, còn phạm vi chính là đường màu cam thể hiện hàng rào bọc ngoài không gian tên này.Nói cách khác, nếu mình muốn sử dụng attr0 nằm trong mô-đun ở trên ở một hàm “bo” chẳng hạn, nếu hàm này không thể truy cập vào phạm vi này thì không thể dùng biến đó được.Cùng xem một ví dụ nhé:Đây là code trong file namespace_student.pyworking_hard = Trueclass Student:   def study(self):      print(&quot;I&#39;m studing.&quot;)Truy cập vào trình biên dịch PI:&gt;&gt;&gt; print(f&#39;working_hard: {working_hard}&#39;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#39;working_hard&#39; is not defined&gt;&gt;&gt; import namespace_student as ns&gt;&gt;&gt; print(f&#39;working_hard: {ns.working_hard}&#39;)working_hard: True&gt;&gt;&gt; print(globals()){&#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None, &#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &#39;__spec__&#39;: None, &#39;__annotations__&#39;: {}, &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;, &#39;ns&#39;: &lt;module &#39;namespace_student&#39; from &#39;/Users/thanhnguyen/Desktop/namespace/namespace_student.py&#39;&gt;}Khi mình làm việc trong PI, mô-đun mặc định ở đây là main, nơi không gian tên có __main__ là giá trị của __name__.Dòng đầu tiên print, mình không thể truy cập vào biến working_hard vì tụi mình đang không đứng trong mô-đun namespace_student. Tuy nhiên, sau khi mình nạp mô-đun này vào, thì mình có thể truy cập tên này không qua tên mô-đun của nó vì ns đã thuộc không gian tên nơi mình đang đứng(main). Mình có thể kiểm tra điều đó bằng hàm in ra không gian tên globals như ở trên.Vì mình có thể dùng tên của mô-đun để truy cập vào các thuộc tính trong đó, cho nên ở các mô-đun khác nhau hoàn toàn có thể chứa các tên giống nhau.Bạn có thể hình dung nó kiểu như là nhà mình có một cái macbook, nhà hàng xóm cũng có một cái macbook y như vậy, thì hai cái macbook này mình có thể hoàn toàn phân biệt được đúng không nào 😀Không gian tên và phạm vi đều phân cấpBạn có để ý thấy chỉ cần truy cập vào trình biên dịch là mình có thể sử dụng các hàm dựng sẵn của Python như print() hay các kiểu dữ liệu như dict(), list().Vậy các bạn này từ đâu ra thế nhỉ ? Vâng, các bạn này thuộc không gian tên dựng sẵn(built-in) đó ạ.Còn khi tạo một mô-đun, ta sẽ có không gian tên toàn cục(global) của mô-đun đó, khi tạo một hàm mình có không gian tên cục bộ(local) của hàm đó. Khi các không gian tên được tạo thì các phạm vi tương ứng của chúng cũng được tạo.  Đặc điểm quan trọng của không gian tên là chúng có mối quan hệ phân cấp như vậy.Biểu đồ dưới thể hiện sự phân cấp này: không gian tên và phạm vi dựng sẵn bao trùm không gian tên và phạm vi toàn cục, và lớp này bao trùm không gian tên và phạm vi cục bộ.Hiểu luật LEGBVì phạm vi xác định việc có thể truy cập đối tượng trong một ranh giới nhất định và chúng có tính phân cấp như trên, những điều này dẫn đến việc chúng cần hiểu và nắm quy luật LEGB – một nguyên tắc giúp xác định thứ tự các phạm vi.LEGB là viết tắc của các phạm vi local, enclosing, global và built-in.Ở trên, mình có đề cập đến các loại phạm vi: local, global, built-in rồi. Thế còn phạm vi bao quanh(enclosing) nghĩa là gì nhỉ?Cùng nhìn ví dụ sau về phạm vi bao quanh nha:Ở ví dụ trên, mình có hàm outer_function có hàm bên trong là inner_function, hàm này có phạm vi cục bộ của riêng nó. Với hàm inner_function, phạm vi của hàm outer_function gọi là phạm vi bao quanh(enclosing scope), tức nó bọc luôn hàm bên trong.Do đó khi hàm inner_function được goi, dù local scope của nó không có hai biến a, b, nhưng trình thông dịch tiếp tục tìm kiếm ở enclosing scope và tìm được hai biến này, do đó kết quả trên được hiển thị ba biến a, b, c.Nếu không thể tìm thấy biến cần tìm không enclosing scope, chương trình sẽ tiếp tục tìm kiếm ở global scope của mô-đun và nếu không có nữa sẽ tìm kiếm tới built-in scope.Nếu tìm hết bốn scope mà vẫn không tìm ra thì chương trình sẽ báo lỗi NameError để chỉ cho mình biết giá trị này chưa được định nghĩa.Do đó, nguyên tắc LEGB định nghĩa thứ tự tìm kiếm của tên theo thứ tự như sau:Và thêm nữa, nếu tên đã được tìm kiếm ở cấp nào rồi, thì chương trình sẽ dừng việc tìm kiếm lại và sử dụng tên đó chứ không đi tìm ở những lớp trên nữa nha, vì tìm ra rồi thì dùng liền chớ hỉ.Ví dụ như ở trên biến a gọi trong hàm inner_function sẽ có giá trị là 11, chứ chương trình không tìm tiếp cấp ở ngoài, nơi a có giá trị là 1 đó.KếtNội dung bài không gian tên và phạm vi đến đây tạm hết rồi, cùng ôn lại hôm ni mình học được gì:      Không gian tên sử dụng dict để theo dõi các đối tượng cùng định danh của chúng        Không gian tên có thể tạo thêm hay xoá bớt một cách linh hoạt        Không gian tên có ranh giới chính là scope, định nghĩa phạm vi tên có thể tìm thấy        Thứ tự tìm tên tuân theo luật LEGB(local, enclosing, global, built-in)  ">
    <meta itemprop="datePublished" content="2021-06-16T00:00:00-04:00">
    <meta itemprop="dateModified" content="2020-06-16T15:12:19-04:00">

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="http://localhost:4000/%C4%91%E1%BA%A1i%20b%E1%BA%A3n%20doanh%20python/khong-gian-ten-va-pham-vi-trong-python/" itemprop="url">Không gian tên(namespace) và phạm vi(scope) trong Python
</a>
          </h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          8 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>Khi mình ngồi học và dịch bài <a href="https://docs.python.org/3/tutorial/classes.html">“Class trong Python”</a> cho sê-ri <a href="https://viblo.asia/s/kham-pha-dai-ban-doanh-python-OVlYq8Ozl8W">“Khám Phá Đại Bản Doanh Python”</a>, mình đã đụng hai bạn này, và các bạn thật là trừu tượng và khó gặm. Thế là mình tìm kiếm và viết bài này để hiểu rõ hơn về hai bạn ấy, hi vọng bạn đọc thêm để hiểu về Python nhé.</p>

<h2 id="không-gian-tên-là-gì">Không gian tên là gì?</h2>

<p>Không gian tên(namespace) là một không gian chứa các tên =))</p>

<p>Thật đó, tên là các định danh, và không gian là các cấu trúc hay các tổ chức, hoặc hiểu đơn giản nó là một vùng nào đó.</p>

<p>Không gian tên trong Python giống như là bảng phân công theo dõi công việc của một nhóm người vậy đó. Bảng phân công thì theo dõi tên người, còn không gian tên trong Python thì theo dõi tên các đối tượng.</p>

<p><em>Thế đối tượng trong Python là gì nhỉ?</em></p>

<p>Có thể bạn đã biết, mọi thứ trong Python đều là đối tượng. Khi mình viết chương trình Python, chúng ta định nghĩa các lớp và mô-đun; sử dụng các cấu trúc list, dict; các thực thể và các hàm.  Tất cả bọn chúng đều là đối tượng cả đó.</p>

<p>Không gian tên trong Python thì theo dõi tên các đối tượng, chẳng hạn như các như các thực thể của đối tượng và các hàm chức năng. Dưới đây là vài đặc điểm quan trọng của khái niệm này:</p>

<h3 id="không-gian-tên-thể-hiện-ở-dạng-từ-điển">Không gian tên thể hiện ở dạng từ điển</h3>

<p>Vì không gian tên thể hiện ánh xạ giữa tên và đối tượng, do đó kiểu dữ liệu có thể thể hiện tham chiếu này chính là từ điển(dict), vì bạn ấy cũng có dạng tham chiếu key-value.</p>

<p>Ví dụ về không gian tên bằng gọi hàm globals(), locals():</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="p">...</span>     <span class="n">b</span> <span class="o">=</span> <span class="mi">11</span>
<span class="p">...</span>     <span class="k">print</span><span class="p">(</span><span class="nb">locals</span><span class="p">())</span>
<span class="p">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Student</span><span class="p">:</span>
<span class="p">...</span>     <span class="k">pass</span>
<span class="p">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">student</span> <span class="o">=</span> <span class="n">Student</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="nb">globals</span><span class="p">())</span>
<span class="p">{</span><span class="s">'__name__'</span><span class="p">:</span> <span class="s">'__main__'</span><span class="p">,</span> <span class="s">'__doc__'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="s">'__package__'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="s">'__loader__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">_frozen_importlib</span><span class="p">.</span><span class="n">BuiltinImporter</span><span class="s">'&gt;, '</span><span class="n">__spec__</span><span class="s">': None, '</span><span class="n">__annotations__</span><span class="s">': {}, '</span><span class="n">__builtins__</span><span class="s">': &lt;module '</span><span class="n">builtins</span><span class="s">' (built-in)&gt;, '</span><span class="n">a</span><span class="s">': [1, 2, 3, 4, 5], '</span><span class="sa">b</span><span class="s">': '</span><span class="n">Hello</span> <span class="n">World</span><span class="err">!</span><span class="s">', '</span><span class="n">foo</span><span class="s">': &lt;function foo at 0x101fd93b0&gt;, '</span><span class="n">foo0</span><span class="s">': &lt;function foo at 0x10200c7a0&gt;, '</span><span class="n">foo1</span><span class="s">': &lt;function foo at 0x10200c7a0&gt;, '</span><span class="n">tracked_namespaces</span><span class="s">': {'</span><span class="n">local</span><span class="s">': {}}, '</span><span class="n">tracked_keys</span><span class="s">': dict_keys(['</span><span class="n">local</span><span class="s">']), '</span><span class="n">ns</span><span class="s">': &lt;module '</span><span class="n">namespaces_student</span><span class="s">' from '</span><span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">ycui</span><span class="o">/</span><span class="n">PythonProjects</span><span class="o">/</span><span class="n">namespaces_student</span><span class="p">.</span><span class="n">py</span><span class="s">'&gt;, '</span><span class="n">working_hard</span><span class="s">': True, '</span><span class="n">Student</span><span class="s">': &lt;class '</span><span class="n">__main__</span><span class="p">.</span><span class="n">Student</span><span class="s">'&gt;, '</span><span class="n">Teacher</span><span class="s">': &lt;class '</span><span class="n">namespaces_teacher</span><span class="p">.</span><span class="n">Teacher</span><span class="s">'&gt;, '</span><span class="n">student</span><span class="s">': &lt;__main__.Student object at 0x102027490&gt;}
&gt;&gt;&gt; foo()
{'</span><span class="sa">b</span><span class="s">': 11}
</span></code></pre></div></div>

<p>Hàm dựng sẵn <strong>globals()</strong> dùng để xem các định danh đi kèm với các đối tượng tương ứng của chính trong không gian tên hiện tại. Kết quả là danh sách các đối tượng được định nghĩa như list, function, class hay thực thể và các hàm dựng sẵn.</p>

<p>Bên cạnh globals() được sử dụng để theo dõi các đối tượng trong mô-đun như ở không gian tên toàn cục như trên, chúng ta còn có thể dùng <strong>locals()</strong> là hàm theo dõi các đối tượng trong một hàm nào đó như là không gian tên địa phương của hàm đó. Trong ví dụ, biến địa phương b được theo dõi trong không gian tên địa phương của hàm foo.</p>

<h3 id="không-gian-tên-có-tính-linh-hoạt">Không gian tên có tính linh hoạt</h3>

<p>Không gian tên được dùng để theo dõi các đối tượng.</p>

<p>Trong Python code, chúng ta tạo ra các đối tượng cố định và xoá các đối tượng không còn được dùng nữa, do đó không gian tên cũng sẽ thay đổi theo dựa trên các thao tác này.</p>

<p>Cùng xem ví dụ khi thực hiện thao tác thêm và xoá các thuộc tính sẽ làm thay đổi không gian tên:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="nb">globals</span><span class="p">().</span><span class="n">keys</span><span class="p">())</span>
<span class="n">dict_keys</span><span class="p">([</span><span class="s">'__name__'</span><span class="p">,</span> <span class="s">'__doc__'</span><span class="p">,</span> <span class="s">'__package__'</span><span class="p">,</span> <span class="s">'__loader__'</span><span class="p">,</span> <span class="s">'__spec__'</span><span class="p">,</span> <span class="s">'__annotations__'</span><span class="p">,</span> <span class="s">'__builtins__'</span><span class="p">,</span> <span class="s">'a'</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="s">'Hi'</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="nb">globals</span><span class="p">().</span><span class="n">keys</span><span class="p">())</span>
<span class="n">dict_keys</span><span class="p">([</span><span class="s">'__name__'</span><span class="p">,</span> <span class="s">'__doc__'</span><span class="p">,</span> <span class="s">'__package__'</span><span class="p">,</span> <span class="s">'__loader__'</span><span class="p">,</span> <span class="s">'__spec__'</span><span class="p">,</span> <span class="s">'__annotations__'</span><span class="p">,</span> <span class="s">'__builtins__'</span><span class="p">,</span> <span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">del</span> <span class="n">c</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="nb">globals</span><span class="p">().</span><span class="n">keys</span><span class="p">())</span>
<span class="n">dict_keys</span><span class="p">([</span><span class="s">'__name__'</span><span class="p">,</span> <span class="s">'__doc__'</span><span class="p">,</span> <span class="s">'__package__'</span><span class="p">,</span> <span class="s">'__loader__'</span><span class="p">,</span> <span class="s">'__spec__'</span><span class="p">,</span> <span class="s">'__annotations__'</span><span class="p">,</span> <span class="s">'__builtins__'</span><span class="p">,</span> <span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">])</span>
</code></pre></div></div>

<p>Khi một hàm được gọi, nó tạo ra một không gian tên cục bộ, và không gian tên này sẽ mất đi khi hàm hoàn thành nhiệm vụ của mình(trả về giá trị hoặc raise lỗi). Khi đó, không gian tên cũng sẽ bị thay đối.</p>

<h3 id="phạm-vi-là-hàng-rào-của-không-gian-tên">Phạm vi là hàng rào của không gian tên</h3>

<p>Để cho dễ hình dung, bạn có thể nghĩ đến scope như là hàng rào quanh nhà bạn, còn namespace là toàn bộ đất trong đó, và trên đất có thể bao gồm cây cối, nhà cửa, …. là các đối tượng.</p>

<p><img src="https://i0.wp.com/beautyoncode.com/wp-content/uploads/2021/01/namespace-scope-pyhon-1.png" alt="" /></p>

<p>Bạn thấy không, không gian tên theo dõi các đối tượng trong mô-đun này, vì tụi này nằm trong không gian của nó, còn phạm vi chính là đường màu cam thể hiện hàng rào bọc ngoài không gian tên này.</p>

<p>Nói cách khác, nếu mình muốn sử dụng attr0 nằm trong mô-đun ở trên ở một hàm “bo” chẳng hạn, nếu hàm này không thể truy cập vào phạm vi này thì không thể dùng biến đó được.</p>

<p>Cùng xem một ví dụ nhé:</p>

<p>Đây là code trong file namespace_student.py</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">working_hard</span> <span class="o">=</span> <span class="bp">True</span>

<span class="k">class</span> <span class="nc">Student</span><span class="p">:</span>
   <span class="k">def</span> <span class="nf">study</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">print</span><span class="p">(</span><span class="s">"I'm studing."</span><span class="p">)</span>
</code></pre></div></div>

<p>Truy cập vào trình biên dịch PI:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'working_hard: </span><span class="si">{</span><span class="n">working_hard</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">NameError</span><span class="p">:</span> <span class="n">name</span> <span class="s">'working_hard'</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">defined</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">namespace_student</span> <span class="k">as</span> <span class="n">ns</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'working_hard: </span><span class="si">{</span><span class="n">ns</span><span class="p">.</span><span class="n">working_hard</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="n">working_hard</span><span class="p">:</span> <span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="nb">globals</span><span class="p">())</span>
<span class="p">{</span><span class="s">'__name__'</span><span class="p">:</span> <span class="s">'__main__'</span><span class="p">,</span> <span class="s">'__doc__'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="s">'__package__'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="s">'__loader__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">_frozen_importlib</span><span class="p">.</span><span class="n">BuiltinImporter</span><span class="s">'&gt;, '</span><span class="n">__spec__</span><span class="s">': None, '</span><span class="n">__annotations__</span><span class="s">': {}, '</span><span class="n">__builtins__</span><span class="s">': &lt;module '</span><span class="n">builtins</span><span class="s">' (built-in)&gt;, '</span><span class="n">ns</span><span class="s">': &lt;module '</span><span class="n">namespace_student</span><span class="s">' from '</span><span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">thanhnguyen</span><span class="o">/</span><span class="n">Desktop</span><span class="o">/</span><span class="n">namespace</span><span class="o">/</span><span class="n">namespace_student</span><span class="p">.</span><span class="n">py</span><span class="s">'&gt;}
</span></code></pre></div></div>

<p>Khi mình làm việc trong PI, mô-đun mặc định ở đây là main, nơi không gian tên có <code class="language-plaintext highlighter-rouge">__main__</code> là giá trị của <code class="language-plaintext highlighter-rouge">__name__</code>.</p>

<p>Dòng đầu tiên print, mình không thể truy cập vào biến working_hard vì tụi mình đang không đứng trong mô-đun namespace_student. Tuy nhiên, sau khi mình nạp mô-đun này vào, thì mình có thể truy cập tên này không qua tên mô-đun của nó vì ns đã thuộc không gian tên nơi mình đang đứng(main). Mình có thể kiểm tra điều đó bằng hàm in ra không gian tên globals như ở trên.</p>

<p>Vì mình có thể dùng tên của mô-đun để truy cập vào các thuộc tính trong đó, cho nên ở các mô-đun khác nhau hoàn toàn có thể chứa các tên giống nhau.</p>

<p>Bạn có thể hình dung nó kiểu như là nhà mình có một cái macbook, nhà hàng xóm cũng có một cái macbook y như vậy, thì hai cái macbook này mình có thể hoàn toàn phân biệt được đúng không nào 😀</p>

<p><img src="https://i0.wp.com/beautyoncode.com/wp-content/uploads/2021/01/namespace-scope-pyhon-2.png?w=1280&amp;ssl=1" alt="" /></p>

<h3 id="không-gian-tên-và-phạm-vi-đều-phân-cấp">Không gian tên và phạm vi đều phân cấp</h3>

<p>Bạn có để ý thấy chỉ cần truy cập vào trình biên dịch là mình có thể sử dụng các hàm dựng sẵn của Python như print() hay các kiểu dữ liệu như dict(), list().</p>

<p>Vậy các bạn này từ đâu ra thế nhỉ ? Vâng, các bạn này thuộc không gian tên dựng sẵn(built-in) đó ạ.</p>

<p>Còn khi tạo một mô-đun, ta sẽ có không gian tên toàn cục(global) của mô-đun đó, khi tạo một hàm mình có không gian tên cục bộ(local) của hàm đó. Khi các không gian tên được tạo thì các phạm vi tương ứng của chúng cũng được tạo.</p>

<blockquote>
  <p><strong>Đặc điểm quan trọng của không gian tên là chúng có mối quan hệ phân cấp như vậy.</strong></p>
</blockquote>

<p>Biểu đồ dưới thể hiện sự phân cấp này: không gian tên và phạm vi dựng sẵn bao trùm không gian tên và phạm vi toàn cục, và lớp này bao trùm không gian tên và phạm vi cục bộ.</p>

<p><img src="https://i2.wp.com/beautyoncode.com/wp-content/uploads/2021/01/namespace-scope-pyhon-3.png?w=1280&amp;ssl=1" alt="" /></p>

<h3 id="hiểu-luật-legb">Hiểu luật LEGB</h3>

<p>Vì phạm vi xác định việc có thể truy cập đối tượng trong một ranh giới nhất định và chúng có tính phân cấp như trên, những điều này dẫn đến việc chúng cần hiểu và nắm quy luật <strong>LEGB</strong> – một nguyên tắc giúp xác định thứ tự các phạm vi.</p>

<p>LEGB là viết tắc của các phạm vi <strong>local</strong>, <strong>enclosing</strong>, <strong>global</strong> và <strong>built-in</strong>.</p>

<p>Ở trên, mình có đề cập đến các loại phạm vi: local, global, built-in rồi. Thế còn phạm vi bao quanh(enclosing) nghĩa là gì nhỉ?</p>

<p>Cùng nhìn ví dụ sau về phạm vi bao quanh nha:</p>

<p><img src="https://i1.wp.com/beautyoncode.com/wp-content/uploads/2021/01/1_NrD4tbuRGT1yLy9gNezGng.png?w=1280&amp;ssl=1" alt="" /></p>

<p>Ở ví dụ trên, mình có hàm <em>outer_function</em> có hàm bên trong là <em>inner_function</em>, hàm này có phạm vi cục bộ của riêng nó. Với hàm <em>inner_function</em>, phạm vi của hàm <em>outer_function</em> gọi là <strong>phạm vi bao quanh</strong>(enclosing scope), tức nó bọc luôn hàm bên trong.</p>

<p>Do đó khi hàm <em>inner_function</em> được goi, dù local scope của nó không có hai biến a, b, nhưng trình thông dịch tiếp tục tìm kiếm ở enclosing scope và tìm được hai biến này, do đó kết quả trên được hiển thị ba biến a, b, c.</p>

<p>Nếu không thể tìm thấy biến cần tìm không enclosing scope, chương trình sẽ tiếp tục tìm kiếm ở global scope của mô-đun và nếu không có nữa sẽ tìm kiếm tới built-in scope.</p>

<p>Nếu tìm hết bốn scope mà vẫn không tìm ra thì chương trình sẽ báo lỗi NameError để chỉ cho mình biết giá trị này chưa được định nghĩa.</p>

<p>Do đó, nguyên tắc LEGB định nghĩa thứ tự tìm kiếm của tên theo thứ tự như sau:</p>

<p><img src="https://i0.wp.com/beautyoncode.com/wp-content/uploads/2021/01/1_Wc-YlKPDuImP4_4TGfbt_g.png?w=1280&amp;ssl=1" alt="" /></p>

<p>Và thêm nữa, nếu tên đã được tìm kiếm ở cấp nào rồi, thì chương trình sẽ dừng việc tìm kiếm lại và sử dụng tên đó chứ không đi tìm ở những lớp trên nữa nha, vì tìm ra rồi thì dùng liền chớ hỉ.</p>

<p>Ví dụ như ở trên biến a gọi trong hàm inner_function sẽ có giá trị là 11, chứ chương trình không tìm tiếp cấp ở ngoài, nơi a có giá trị là 1 đó.</p>

<h3 id="kết">Kết</h3>

<p>Nội dung bài không gian tên và phạm vi đến đây tạm hết rồi, cùng ôn lại hôm ni mình học được gì:</p>

<ul>
  <li>
    <p>Không gian tên sử dụng dict để theo dõi các đối tượng cùng định danh của chúng</p>
  </li>
  <li>
    <p>Không gian tên có thể tạo thêm hay xoá bớt một cách linh hoạt</p>
  </li>
  <li>
    <p>Không gian tên có ranh giới chính là scope, định nghĩa phạm vi tên có thể tìm thấy</p>
  </li>
  <li>
    <p>Thứ tự tìm tên tuân theo luật LEGB(local, enclosing, global, built-in)</p>
  </li>
</ul>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#python" class="page__taxonomy-item p-category" rel="tag">python</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#%C4%91%E1%BA%A1i-b%E1%BA%A3n-doanh-python" class="page__taxonomy-item p-category" rel="tag">Đại Bản Doanh Python</a>
    
    </span>
  </p>


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2020-06-16">June 16, 2020</time></p>

      </footer>

      <section class="page__share">
  <h4 class="page__share-title">Share on</h4>

  <a href="https://twitter.com/intent/tweet?via=mmistakes&text=Kh%C3%B4ng+gian+t%C3%AAn%28namespace%29+v%C3%A0+ph%E1%BA%A1m+vi%28scope%29+trong+Python%20http%3A%2F%2Flocalhost%3A4000%2F%25C4%2591%25E1%25BA%25A1i%2520b%25E1%25BA%25A3n%2520doanh%2520python%2Fkhong-gian-ten-va-pham-vi-trong-python%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2F%25C4%2591%25E1%25BA%25A1i%2520b%25E1%25BA%25A3n%2520doanh%2520python%2Fkhong-gian-ten-va-pham-vi-trong-python%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://localhost:4000/%C4%91%E1%BA%A1i%20b%E1%BA%A3n%20doanh%20python/khong-gian-ten-va-pham-vi-trong-python/" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/%C4%91%E1%BA%A1i%20b%E1%BA%A3n%20doanh%20python/iterator-va-generator-trong-python/" class="pagination--pager" title="Iterable, Iterator và Generator trong Python">Previous</a>
    
    
      <a href="/%C4%91%E1%BA%A1i%20b%E1%BA%A3n%20doanh%20python/lop-trong-python/" class="pagination--pager" title="Lớp trong Python">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
    
<div class="page__related">
  <!-- <div align="center" style="margin: 1em 0;">
  <ins class="adsbygoogle"
        style="display:block; border-bottom: initial;"
        data-ad-client="ca-pub-7328585512091257"
        data-ad-slot="3049671934"
        data-ad-format="auto"
        data-full-width-responsive="true"></ins>
</div> -->


  <h2 class="page__related-title">You May Also Enjoy</h2>
  <div class="grid__wrapper">
    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/django/django%20rest%20framework%20(drf)/relation-fields-in-drf-serializer/" rel="permalink">Relation fields in Django Rest Framework Serializer
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          5 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
The Django model offers various types of relationships such as OneToOneField, ForeignKey, ManyToManyField, and GenericForeignKey.

</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/django/export-multiple-csv-to-zip-django/" rel="permalink">Export multiple CSV files into a ZIP in Django Application
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          6 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">

</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/django/export-docx-in-django/" rel="permalink">Export a docx file in Django application
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          8 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">

</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/js/scope-trong-javascript/" rel="permalink">Scope trong JavaScript
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          2 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">

</p>
  </article>
</div>

    
  </div>
</div>

  
  
</div>

      <!-- <div align="center" style="margin: 1em 0;">
  <ins class="adsbygoogle"
        style="display:block; border-bottom: initial;"
        data-ad-client="ca-pub-7328585512091257"
        data-ad-slot="3049671934"
        data-ad-format="auto"
        data-full-width-responsive="true"></ins>
</div> -->

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><div class="search-searchbar"></div>
  <div class="search-hits"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://www.linkedin.com/in/graphicdthanh/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://www.facebook.com/beautyoncode" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i> Facebook</a></li>
        
      
        
          <li><a href="https://github.com/GraphicDThanh" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2024 <a href="http://localhost:4000">BeautyOnCode</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>


<script>
// Including InstantSearch.js library and styling
const loadSearch = function() {
  const loadCSS = function(src) {
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = src;
    link.media = 'all';
    document.head.appendChild(link);
  };

  var script = document.createElement('script');
  script.setAttribute("type", "text/javascript");
  script.setAttribute("src", "https://cdn.jsdelivr.net/npm/instantsearch.js@2.3.3/dist/instantsearch.min.js");
  script.addEventListener("load", function() {
    // Instantiating InstantSearch.js with Algolia credentials
    const search = instantsearch({
      appId: 'QB6HVGBSBA',
      apiKey: '9d5014e5bbc77372547bce778dfa5663',
      indexName: 'minimal_mistakes',
      searchParameters: {
        restrictSearchableAttributes: ['title', 'content']
      }
    });

    const hitTemplate = function(hit) {
      const url = hit.url;
      const hightlight = hit._highlightResult;
      const title = hightlight.title && hightlight.title.value  || "";
      const content = hightlight.html && hightlight.html.value  || "";

      return `
        <div class="list__item">
          <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
            <h2 class="archive__item-title" itemprop="headline"><a href="${url}">${title}</a></h2>
            <div class="archive__item-excerpt" itemprop="description">${content}</div>
          </article>
        </div>
      `;
    }

    // Adding searchbar and results widgets
    search.addWidget(
      instantsearch.widgets.searchBox({
        container: '.search-searchbar',
        poweredBy: true,
        placeholder: 'Enter your search term...'
      })
    );
    search.addWidget(
      instantsearch.widgets.hits({
        container: '.search-hits',
        templates: {
          item: hitTemplate,
          empty: 'No results',
        }
      })
    );

    if (!search.started) {
      search.start();
    }
  });
  document.body.appendChild(script);

  loadCSS("https://cdn.jsdelivr.net/npm/instantsearch.js@2.3.3/dist/instantsearch.min.css");
  loadCSS("https://cdn.jsdelivr.net/npm/instantsearch.js@2.3.3/dist/instantsearch-theme-algolia.min.css");
};

// Starting the search only when toggle is clicked
$(document).ready(function() {
  var scriptLoaded = false;

  $(".search__toggle").on("click", function() {
    if (!scriptLoaded) {
      loadSearch();
      scriptLoaded = true;
    }
  });
});
</script>




<style>
.google-auto-placed {
  margin: 2em auto;
}
</style>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>(adsbygoogle = window.adsbygoogle || []).push({});</script>




  </body>
</html>
